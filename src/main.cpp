/**	NIM:		13515065
	Nama:		Felix Limanta
	Tanggal:	24 Februari 2017
	File:		main.cpp
	Topik;		Divide and Conquer
	Deskripsi:	Driver algoritma sorting
  */

#include "merge_sort.h"
#include "insertion_sort.h"
#include "quick_sort.h"
#include "selection_sort.h"
#include <cstdlib>
#include <ctime>
#include <fstream>
#include <iostream>
#include <random>
#include <string>

using namespace std;

#define GEN_RANDOM		0
#define MERGE_SORT 		1
#define INSERTION_SORT 	2
#define QUICK_SORT 		3
#define SELECTION_SORT 	4

/**	Function definition
  */
void generate_random (size_t size);
int* load_unsorted (size_t size);
bool is_sorted (int data[], size_t size);
void save_sorted (int data[], size_t size, char sort_type, int64_t execution_time);

int main(int argc, char* argv[]) {
	int action;
	size_t size;
	
	cout << "Action:    0. Generate random data\n" <<
			"           1. Merge sort\n" <<
			"           2. Insertion sort\n" <<
			"           3. Quick sort\n" <<
			"           4. Selection sort\n" <<
			"Action:    ";
	if (argc < 2) {
		cin >> action;
	} else {
		action = atoi(argv[1]);
		cout << action << '\n';
	}
	
	cout << "Data size: ";
	if (argc < 3) {
		cin >> size;
	} else {
		size = atoi(argv[2]);
		cout << size << '\n';
	}
	
	if (action == GEN_RANDOM) {
		// Random data generation
		generate_random(size);		
		cout << "Random data generated" << '\n';
		
	} else {
		// Sorting
		int* data = load_unsorted(size);
		int64_t start_time = clock();
		switch (action) {
			case MERGE_SORT:
				merge_sort(data, size); break;
			case INSERTION_SORT:
				insertion_sort(data,size); break;
			case QUICK_SORT:
				quick_sort(data,size); break;
			case SELECTION_SORT:
				selection_sort(data,size); break;				
		}
		
		// Measure execution time
		int64_t end_time = clock();
		int64_t exec_time = (end_time - start_time) * 1000 / CLOCKS_PER_SEC;
		
		// Check integrity and output result
		if (is_sorted(data,size)) {
			save_sorted(data,size,action,exec_time);
			cout << "Data sorted successfully\n" <<
					"Execution time: " << exec_time;
		} else {
			save_sorted(data,size,action,exec_time);
			cout << "Sorting failed" << '\n' << 
					"Execution time: " << exec_time;
		}
	}
		
	return 0;
}

/**	@brief	Random Number Generator
	Generates a text file containing randomly generated unsigned integer
	File is saved to path "../output/{size}_unsorted.txt"
	First line of file contains file name as header
	Data starts at third line
	@param	size	Number of data in file	
  */
void generate_random (size_t size) {
	ofstream outf;
	string fname = "../output/" + to_string(size) + "_unsorted.txt";
	outf.open(fname.c_str(), ios::out);
	
	if (outf.is_open()) {
		unsigned int seed = time(NULL);
		subtract_with_carry_engine<unsigned,24,10,24> generator (seed);		
		outf << fname << "\n\n";
		for (size_t i = 0; i < size; ++i) {
			outf << generator() << '\n';
		}
		outf.close();	
	}
}

/**	@brief Load unsorted file
	Loads file containing unsorted data as generated by function generate_random
	Loads "../output/{size}_unsorted.txt"
	@param	size	Number of data to be loaded
	@return	Pointer to array containing data
  */
int* load_unsorted (size_t size) {
	ifstream inf;
	string fname = "../output/" + to_string(size) + "_unsorted.txt";
	inf.open(fname.c_str(), ios::in);
	
	if (inf.is_open()) {
		int* data = new int[size];
		string instr;
		getline(inf, instr);
		getline(inf, instr);
		for (size_t i = 0; i < size; ++i) {
			getline(inf, instr);
			data[i] = stoi(instr);
		}
		inf.close();
		return data;
	} else
		return NULL;	
}

/**	@brief 	Check if data is sorted
	@param 	data	Array to be checked
	@param	size	Size of array
	@return	True if data is sorted ascending
  */
bool is_sorted (int data[], size_t size) {
	bool sorted = true;
	for (size_t i = 1; sorted && i < size; ++i)
		sorted = data[i-1] <= data[i];
	return sorted;
}

/**	@brief	Save sorted data to text file
	File is saved to path "../output/{size}_{algorithm}.txt"
	@param	data		Array of sorted data to be saved
	@param	size		Size of array
	@param	sort_type	Type of sorting
	@param	exec_time	Execution time of sorting algorithm	
  */
void save_sorted (int data[], size_t size, char sort_type, int64_t exec_time) {
	ofstream outf;
	string fname = "../output/" + to_string(size);
	switch (sort_type) {
		case MERGE_SORT:
			fname += "_merge_sort.txt"; break;
		case SELECTION_SORT:
			fname += "_selection_sort.txt"; break;
		case QUICK_SORT:
			fname += "_quick_sort.txt"; break;
		case INSERTION_SORT:
			fname += "_insertion_sort.txt"; break;
	}
	outf.open(fname,ios::out);
	
	if (outf.is_open()) {		
		outf << fname << '\n' << exec_time << "\n\n";
		for (size_t i = 0; i < size; ++i) {
			outf << data[i] << '\n';
		}
		outf.close();
	}	
}